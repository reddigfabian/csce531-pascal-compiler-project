functions he said we would need for Project part 1:

SYMBOL TABLE FUNCTIONS:
    st_enter_id
        enroll/retrieve an ID structure (ST_ID)
        DOES NOT INSTALL

    st_lookup(id, &block)
        block = address of an L value?!?!
        he said make sure you always supply one
        enter scope, block# increases
        leave scope, block# decreases
        project part one, everything is global, so only 1 block (block 1)
            have to pass in something tho, so it can set that memory address, even if user
            isnt going to use, otherwise it could trash some random memory and create seg faults
            just make a unused var and pass in its address
        return data record (ST_DR) for the id, if installed (otherwise return null)

    st_install
        installs an id with a data record into the symtab

    st_get_id_str
        returns actual string (char *) of an ID.

    stdr_alloc
        allocates a new, uninitialized data record.
        returns new record
        call this, then fill in fields of the record, then st_install

    st_get_cur_block
        probably not used till next project part.
        returns current block number.

TYPES MODULE:
    for building and analyzing structures for supporting Pascal types
    originaly built for a c compiler (effects the function names)

    ty_build
        type building functions

    ty_build_array, ty_build_ptr, ty_build_func, ty_build_basic (TYPETAG)
    ty_build_unresolved_ptr, ty_build_subrange

    Pascal basic types equivalent:
        Pascal   -  C
        Integer  -  long int
        Char     -  unsigned char
        Boolean  -  char (signed)   0=False and 1=True
        Real     -  double
        Single   -  float

    typetags
        TYSIGNEDLONGINT
        TYPTR            - pointer type
        TYARRAY          - array types
        TYFUNC           - func types

    type structure (TYPE)
                 for an array:
                 typetag
                 list of index types - linked list  (1D, 2D, 3D arrays info also)
                 elementtype     - what type is the element in the array

        ex:
            var
            a : array[2..4,3..10] of Real
            ----------------------------
            2..4  = subrange of Integer
            3..10 = subrange of Integer
                    Integer = base type
                        call ty_build_basic to get basic type
                        then ty_build_subrange, include basetype from basic
                        include upper and lower limits (the 2,4 and the 3,10)
            typetag = TYARRAY
            index list = 2 elements = both subranges of Integer
            element type = Real

        you can assume all index types are integer subranges
        lowerbound needs to be less than or equal to upperbound
                                            or symantic error

        cant have an array of functions.
        TYFUNC, not a data type
        but can have pointers to function types.


        ty_query(TYPE)
            returns TYPETAG

        depending on typetag (use a switch maybe)
         ty_query_array
         ty_query_ptr
         ty_query_func

BACK END:
    outputting assembly code (x86)
    architecture - independent interface

    only need two functions for PART 1:

        b_global_decl(id, align, size)
            -only put label down, doesnt allocate memory

        b_skip(size)
            -adds allocated memory

        -----generaly used together (most the time)

    Alignment & size:
        type    alignment   size
        -------------------------
        Char         1        1
        Boolean      1        1
        Integer      4        4
        Real         8        8
        Single       4        4
        Pointer      4        4




We need to use the modules, but cant modify them. only exception is to add include
statements to allow for different data types in c (like in scan.l and gram.y)

=============================March 16==========================================================================================

type

new identifier      type denoter
______________  =   ____________;

"Enroll" every (new) identifier into the symbol table:
    ST_ID st_enter_id(char *str);  <===parameter is text of the identifier
    ^
    This function returns a pointer to a symbol table record that acts as "enrollment papers"

      *The symbol table enforces unique identifiers, therefore an identifier must be enrolled as soon as possible when it is found
        It also allows us to test equality of identifiers by testing pointer equivalence



enroll    vs    install

    enroll any # of times

    when you install you produce a symbol table data record(ST_DR), fill in the fields, and call st_install(  )

    EXAMPLE:
        type
            IntArray = array[1..10] of Integer; ('array[1..10] of Integer' is a TYPE)

            as soon as you recognize IntArray you enroll is, but once you've processed the entire line, you
            install IntArray(ST_ID) into the symbol table as a TYPENAME with the corresponding type(TYPE) by calling st_install
                  mystDR = st_stdr_alloc(); <== new ST_DR
                  //fill in the fields appropriately
                    st_install(mystDR);//returns whether or not the install was correct, based on whether or not you are attempting to install a duplicate

===============================================================================================================================

==========================March 18=============================================================================================

Symbol Table - supports storing & retrieving information about user defined identifiers

st_lookup - looks up an identifier in the symbol table by the ST_ID and returns the complete data record (only if it is installed, otherwise returns null)

===============================================================================================================================
